---
title: Funci贸n maliciosa
description: Funci贸n que modifica la direcci贸n de retorno para se ejecute ella de nuevo
layout: ../../../layouts/MainLayout.astro
---

import Code from "../../../components/Code/Code";
import Solution from "../../../components/Solution";

Funci贸n que modifica la direcci贸n de retorno para se ejecute ella de nuevo.

En este ejemplo se trata de hacer algo un poco m谩s complejo jugando con los conocimientos de la M++.

Como ya sabemos, cuando se llama a una funci贸n, la ejecuci贸n salta a la direcci贸n de memoria
de dicha funci贸n y se ejecuta hasta que se encuentra con la instrucci贸n de retorno ([`RET`](/es/instructions/RET)).
Es entonces cuando la ejecuci贸n vuelve a la siguiente direcci贸n de memoria de la funci贸n que la llam贸.

Internamente la M++ guarda esta direcci贸n de retorno en la pila (stack) al llamar a la funci贸n
y la recupera para retornar.

#### Pero... y si modifico la pila (stack) antes de retornar? 

## Funciones de ayuda

Necesitaremos realizar restas de numeros de 16 bits, creando la logica de dicha funcionalidad en una funci贸n a parte.
Estas funciones auxiliares van a operar con los registros RD y RE donde guardaremos direcciones de memoria.

Primero las vamos a ver en java.

```java
void TFSUB_RD() {
    RD = RD - 1;
}

void TFSUB_RE() {
    RE = RE - 1;
}

void TFSUB() {
    TFSUB_RE(); // siempre restamos 1 al registro RE
    if (RE == 0xFF) {
        // (*) si el registro RE es 0xFF, sabemos que antes de restar 1 al RE estaba en 0x00
        // por lo que debemos restar 1 al registro RD
        TFSUB_RD();
    }
}
```

**(\*)** Esto en el codigo de la M++ no es tan literal, ya que en vez de comprobar si el registro RE es 0xFF,
comprobamos si est谩 activado el flag de carry.

El c贸digo en la M++ es:

<Code
  testCodeText="Probar c贸digo"
  code={`# util functions\nTFSUB CALL TFSUB_RE\nBC TFSUBRD # (*)\nJMP TFSUBRET\n\nTFSUBRD CALL TFSUB_RD\n\nTFSUBRET RET\n\n#RD = RD - 1\nTFSUB_RD MOV RD, AC\nSUB 01\nMOV AC, RD\nRET\n\n# RE = RE - 1\nTFSUB_RE MOV RE, AC\nSUB 01\nMOV AC, RE\nRET`}
  client:load
/>

Gracias a estas funciones ya podemos realizar restas de 16 bits.

Los pasos a seguir son:

- Encontrar la direcci贸n de memoria de retorno.
- Encontrar la direcci贸n de memoria del que llam贸 a nuestra funci贸n.
- Sobreescribir la direcci贸n de memoria de retorno en la pila (stack) con la direcci贸n de memoria de la funci贸n que llam贸 a nuestra funci贸n.
- ...creando as铆 una funci贸n que decide volver a ejecutarse de nuevo... 

## Pero...

### Y si en vez de hacer todo esto, simplemente llamamos a la funci贸n de nuevo?

```java
int sumar(int a, int b) {
    return sumar(a, b); // por ejemplo
}
```

El resultado va a ser "parecido" pero no lo es.

Ya hemos visto que al llamar a una funci贸n guardamos la informaci贸n de retorno en la pila.
Si llamamos a la funci贸n de nuevo, estaremos acumulando datos en la pila hasta que llegue nos quedemos "sin memoria"
o lo que es peor, que la propia pila sobrescriba nuestras instrucci贸nes en memoria .

De la forma planteada inicialmente no hay anidaci贸n ya que todo el rato se sobrescribe la direcci贸n de retorno de la pila.

## C贸digo final

<Code
  testCodeText="Probar c贸digo"
  code={`INISP EEEE # random far address\nCALL TFAUTORECURSIVE\nFIN\n\n\nTFAUTORECURSIVE POP # extract return address\nMOV AC, RE\nPOP\nMOV AC, RD\n# --\n\n# find caller address\nCALL TFSUB\nCALL TFSUB\nCALL TFSUB\n# --\n\n# faking return address\n# - creating recursive call\nMOV RD, AC\nPUSH\nMOV RE, AC\nPUSH\n# --\n\nRET\n\n# util functions\nTFSUB CALL TFSUB_RE\nBC TFSUBRD\nJMP TFSUBRET\n\nTFSUBRD CALL TFSUB_RD\n\nTFSUBRET RET\n\nTFSUB_RD MOV RD, AC\nSUB 01\nMOV AC, RD\nRET\n\nTFSUB_RE MOV RE, AC\nSUB 01\nMOV AC, RE\nRET`}
  client:load
/>
